Tutorial
========

The Bower object
----------------

To get started with BowerStatic you need a ``Bower``
instance. Typically you only have one globally installed ``Bower``
instance in your application, but you could have multiple ones.

You create it like this::

  import bowerstatic

  bower = bowerstatic.Bower()

Declaring Bower Directories
---------------------------

Bower manages a directory in which it installs packages. This
directory is called ``bower_components`` by default. Bower installs
packages into this directory as sub-directories.

Packages in a Bower-managed directory can depend on each other, but
not on packages installed in another directory -- each Bower directory
is an "isolated universe" of packages.

You need to let BowerStatic know where these directories are by adding
them to the ``bower`` object::

  components = bower.directory('components', '/path/to/bower_components')

You need to give each Bower directory a unique name, in this case
``components``. This name will be used in the URL used to serve
packages in this directory to the web, later. We assign the created
directory object to a global variable ``components`` we use later.

Publisher: Serving Static Resources
-----------------------------------

Now that the ``bower`` object knows about which Bower directories to
serve, you can let it serve its contents as static resources. You need
to use a special WSGI framework component to do this, the
publisher. You wrap your WSGI application with this framework
component to give it the ability to serve these static resources to
the web. Here's how you do this::

  app = bower.publisher(my_wsgi_app)

``app`` is now a WSGI application that does everything ``my_wsgi_app``
does, as well as serve Bower components under the special URL
``/bowerstatic``.

Injector: Injecting Static Resources
------------------------------------

BowerStatic also automates the inclusion of static resources in your
HTML page, by inserting the appropriate ``<script>`` and ``<link>``
tags. This is done by another WSGI framework component, the injector.

You need to wrap the injector around your WSGI application as well::

  app = bower.injector(my_wsgi_app)

Wrap: Doing it all at once
--------------------------

Typically you will need both the injector and the publisher to wrap
your WSGI application. You can do this by hand::

  app = bower.publisher(bower.injector(my_wsgi_app))

but you can also do it in one easy step::

  app = bower.wrap(my_wsgi_app)

Including Static Resources in a HTML page
-----------------------------------------

Now that you serve the static resources and have the injector
installed, you need to be able to easily refer to resources from
Python so they are included on the web pages you want.

Using the ``components`` object we created earlier for a bower
directory, you create a ``include`` function::

  include = components.includer(environ)

You need to create the ``include`` function within your WSGI
application, typically just before you use it specify what static
resources you want to include. You need to pass in the WSGI
``environ`` object, as this is where the inclusions will be
stored. You can create the ``include`` function as many times as you
like for a WSGI environ; the inclusions are shared.

Now you can use the ``include`` function to include resources::

  include('jquery/dist/jquery.js')

This specifies you want to include the ``dist/jquery.js`` resource
from within the installed ``jquery`` package. ``dist/jquery.js`` is a
file within the package. It is an error to refer to a non-existent
file.

Doing this results in the injector adding the following ``<script>`` tag
to the HTML page generated by your WSGI application::

  <script
    type="text/javascript"
    src="/bowerstatic/components/jquery/2.1.1/dist/jquery.js">
  </script>

URL structure
-------------

Let's look at the URLs used by BowerStatic for a moment::

  /bowerstatic/components/jquery/2.1.1/dist/jquery.js

``bowerstatic``
  The BowerStatic signature. You can change the default signature used
  by passing a ``signature`` argument to the ``Bower`` constructor.

``components``
  The unique name of the bower directory which you gave when you did an ``.add``.

``jquery``
  The name of the installed package as given by the ``name``
  field in ``bower.json``.

``2.1.1``
  The version number of the installed package as given by the ``version``
  field in ``bower.json``.

``dist/jquery.js``
  A relative path to a file within the package.

Caching
-------

BowerStatic makes sure that resources are served with caching headers
set to cache them forever [#forever]_. This means the browser does not
request them from the server again after loading them once. If you
install a caching proxy like Varnish or Squid in front of your web
server, or use Apache ``mod_cache``, the WSGI server only has to serve
the resource once, and then it served by cache forever.

Caching forever would not normally be advisable as it would make it
hard to upgrade to newer versions of packages. You would have to teach
your users to issue a shift-reload to get the new version of
JavaScript code. But with BowerStatic this is safe, as it includes the
version number of the package in the URLs. When a new version of a
package is installed, the version number is updated, and new URLs are
generated by the include mechanism.

.. [#forever] Well, for 10 years. But that's forever in web time.

Main endpoint
-------------

Bower has a concept of a ``main`` end-point for a package in its
``bower.json``. You can include the main endpoint by including the
package without any specific file::

  include('jquery')

This includes the file listed in the ``main`` field in ``bower.json``.
In the case of jQuery, this is the same file as we already included
in the earlier examples: ``dist/jquery.js``.

A package can also specify an array of files in ``main``, and
BowerJson will in that case include all of them.

XXX is that the correct behavior? maybe the first?

The endpoint system is aware of Bower intra-package dependencies.
Suppose you include 'jquery-ui'::

  include('jquery-ui')

The ``jquery-ui`` package specifies in the ``dependencies`` field in
its ``bower.json`` that it depends on the ``jquery`` package. When you
include the ``jquery-ui`` endpoint, BowerStatic automatically also
include the ``jquery`` endpoint for you. You therefore get two
inclusions in your HTML::

  <script
    type="text/javascript"
    src="/bowerstatic/static/jquery/2.1.1/dist/jquery.js">
  </script>
  <script
    type="text/javascript"
    src="/bowerstatic/static/jquery-ui/1.10.4/ui/jquery-ui.js">
  </script>

Thoughts
--------

* The 'bower' object may be a global, as in many setups you'd have
  only one. I chose to make it explicit though.

* You can change which ``bower_components`` directory is used by using
  a different includer, as bower components directories are mapped to
  names (in this case 'static').

* OO modeling. We could create a ``BowerComponents``, ``Package`` and
  ``Resource`` abstraction along the lines of Fanstatic, meaning it
  can be more than just a string or a tuple. This might make for a
  nice API. But it also might create dependencies between packages
  resources and the ``bower`` object, something Fanstatic has, but
  perhaps it'd be simpler to avoid it. I'll explore this during coding
  and writing tests.

* There is no notion of a Python package that contains dependency
  information, though those could be created; they could contain a
  function that takes a 'bower' object and then calls ``depends`` on
  it for whatever resource information they like.

* The system to mark dependencies could be expanded to mark other
  relationships between resources, including source versus minified
  version, or bundle versus individual bit. It might also be possible
  to export the dependency information to a client-side resource
  inclusion system like RequireJS.
