Tutorial
========

The Bower object
----------------

To get started with BowerStatic you need a ``Bower``
instance. Typically you only have one globally installed ``Bower``
instance in your application, but you could have multiple ones.

You create it like this::

  import bowerstatic

  bower = bowerstatic.Bower()

Declaring Bower Directories
---------------------------

Bower manages a directory in which it installs packages. This
directory is called ``bower_components`` by default. Bower installs
packages into this directory as sub-directories.

Packages in a Bower-managed directory can depend on each other, but
not on packages installed in another directory -- each Bower directory
is an "isolated universe" of packages.

You need to let BowerStatic know where these directories are by adding
them to the ``bower`` object::

  components = bower.components('components', '/path/to/bower_components')

You need to give each Bower directory a unique name, in this case
``components``. This name will be used in the URL used to serve
packages in this directory to the web, later. We assign the created
directory object to a global variable ``components`` we use later.

Publisher: Serving Static Resources
-----------------------------------

Now that the ``bower`` object knows about which Bower directories to
serve, you can let it serve its contents as static resources. You need
to use a special WSGI framework component to do this, the
publisher. You wrap your WSGI application with this framework
component to give it the ability to serve these static resources to
the web. Here's how you do this::

  app = bower.publisher(my_wsgi_app)

``app`` is now a WSGI application that does everything ``my_wsgi_app``
does, as well as serve Bower components under the special URL
``/bowerstatic``.

Injector: Injecting Static Resources
------------------------------------

BowerStatic also automates the inclusion of static resources in your
HTML page, by inserting the appropriate ``<script>`` and ``<link>``
tags. This is done by another WSGI framework component, the injector.

You need to wrap the injector around your WSGI application as well::

  app = bower.injector(my_wsgi_app)

Wrap: Doing it all at once
--------------------------

Typically you will need both the injector and the publisher to wrap
your WSGI application. You can do this by hand::

  app = bower.publisher(bower.injector(my_wsgi_app))

but you can also do it in one easy step::

  app = bower.wrap(my_wsgi_app)

Including Static Resources in a HTML page
-----------------------------------------

Now that you serve the static resources and have the injector
installed, you need to be able to easily refer to resources from
Python so they are included on the web pages you want.

Using the ``components`` object we created earlier for a bower
directory, you create a ``include`` function::

  include = components.includer(environ)

You need to create the ``include`` function within your WSGI
application, typically just before you use it specify what static
resources you want to include. You need to pass in the WSGI
``environ`` object, as this is where the inclusions will be
stored. You can create the ``include`` function as many times as you
like for a WSGI environ; the inclusions are shared.

Now you can use the ``include`` function to include resources::

  include('jquery/dist/jquery.js')

This specifies you want to include the ``dist/jquery.js`` resource
from within the installed ``jquery`` package. ``dist/jquery.js`` is a
file within the package. It is an error to refer to a non-existent
file.

Doing this results in the injector adding the following ``<script>`` tag
to the HTML page generated by your WSGI application::

  <script
    type="text/javascript"
    src="/bowerstatic/components/jquery/2.1.1/dist/jquery.js">
  </script>

URL structure
-------------

Let's look at the URLs used by BowerStatic for a moment::

  /bowerstatic/components/jquery/2.1.1/dist/jquery.js

``bowerstatic``
  The BowerStatic signature. You can change the default signature used
  by passing a ``signature`` argument to the ``Bower`` constructor.

``components``
  The unique name of the bower directory which you gave when you did an ``.add``.

``jquery``
  The name of the installed package as given by the ``name``
  field in ``bower.json``.

``2.1.1``
  The version number of the installed package as given by the ``version``
  field in ``bower.json``.

``dist/jquery.js``
  A relative path to a file within the package.

Caching
-------

BowerStatic makes sure that resources are served with caching headers
set to cache them forever [#forever]_. This means the browser does not
request them from the server again after loading them once. If you
install a caching proxy like Varnish or Squid in front of your web
server, or use Apache ``mod_cache``, the WSGI server only has to serve
the resource once, and then it served by cache forever.

Caching forever would not normally be advisable as it would make it
hard to upgrade to newer versions of packages. You would have to teach
your users to issue a shift-reload to get the new version of
JavaScript code. But with BowerStatic this is safe, as it includes the
version number of the package in the URLs. When a new version of a
package is installed, the version number is updated, and new URLs are
generated by the include mechanism.

.. [#forever] Well, for 10 years. But that's forever in web time.

Main endpoint
-------------

Bower has a concept of a ``main`` end-point for a package in its
``bower.json``. You can include the main endpoint by including the
package without any specific file::

  include('jquery')

This includes the file listed in the ``main`` field in ``bower.json``.
In the case of jQuery, this is the same file as we already included
in the earlier examples: ``dist/jquery.js``.

A package can also specify an array of files in ``main``. In this case
the first endpoint listed in this array is included.

The endpoint system is aware of Bower intra-package dependencies.
Suppose you include 'jquery-ui'::

  include('jquery-ui')

The ``jquery-ui`` package specifies in the ``dependencies`` field in
its ``bower.json`` that it depends on the ``jquery`` package. When you
include the ``jquery-ui`` endpoint, BowerStatic automatically also
include the ``jquery`` endpoint for you. You therefore get two
inclusions in your HTML::

  <script
    type="text/javascript"
    src="/bowerstatic/static/jquery/2.1.1/dist/jquery.js">
  </script>
  <script
    type="text/javascript"
    src="/bowerstatic/static/jquery-ui/1.10.4/ui/jquery-ui.js">
  </script>

Local components
----------------

Now we have a way to publish and use Bower packages. But you also
develop your own front-end code: so-called "local
components". BowerStatic also helps with that. For this it is
important to understand that locally developed code has special
caching requirements:

* When you release a local component, you want it to be cached
  infinitely just like for Bower components.

  But when later a new release is made, you want that cache to be
  invalidated, and not force end-users to do a shift-reload to get
  their browser to load the new version of the code. We can accomplish
  this by using a version number in the URL, just like for Bower
  components.

  XXX one way to release a local component would be to release it
  as a bower component at this point. But this may be cumbersome
  for code maintained as part of Python package.

* When you *develop* a local component, you want the cache to be
  invalidated as soon as you make any changes to the code, so you
  aren't forced to do shift-reload either. A way to look at this is
  that you want the system to make a new version number for each and
  every edit to the local component.

To have local components, you first need a special local components
registry::

  local = bower.local_components('local')

You can have more than one local components registry, but typically
you only need one per project. It does not point to a
``bower_components`` directory to find its components. Instead, multiple
directories can be registered into it manually.

Here's how we would add a local component called ``mycode``::

  local.component('mycode', '/path/to/directory/mycode', version='1.1.0')

XXX since 'main' is also useful, we *should* use bower.json for the name
  and version. Though version rules are special.

A component is defined by a unique name (which is used in its URL),
a path to a directory with client-side code in it that you want
to publish under that name, and a version.

The directory with client-side code in it can have any structure. It
could have a ``bower.json`` in it, but this is not inspected by the
local components registry. You could organize it so that the local
component is within a Python package.

If you have a file ``app.js`` in the local component directory, it
is published under this URL::

  /bowerstatic/local/mycode/1.1.0/app.js

To be able to include it, we need to construct an includer that also
looks at the local components if it cannot find it in the
bower components::

  include = components.includer(environ, local=local)

You can now include ``app.js`` in ``mycode`` like this::

  include('mycode/app.js')

Versioning
~~~~~~~~~~

Let's consider versioning in more detail.

``version`` is the version number that the package should appear
under. You can pick this up from the application version, so that a
new release of the application automatically updates the version
number of all local packages (busting the cache).

You could for instance pick it up from the Python project's
``setup.py`` like this::

  import pkg_resources

  version = pkg_resources.get_distribution('myproject').version

You can also leave off ``version`` or set it to ``None``. This
triggers ``devmode`` for that local component. It causes the version
to be automatically determined from the code in the package, and be
different each time you edit the code. Since the version is included
in the URL to the package, this allows you to get the latest version
of the code as soon as you reload after editing a file. No
shift-reloads needed to reload the code!

Devmode is relatively expensive, as BowerStatic has to monitor the
local directory for any changes to update the version number. You
should make sure you don't able it during a release, but pass the real
version number itself.

If your application has a notion of a development mode that you can
somehow inspect during run-time, you can write a version function that
automatically returns ``None`` in development mode and otherwise returns
the application's version number. This ensures optimal caching behavior
during development and deployment both. Here's what this function could
look like::

  def get_version():
      if is_devmode_enabled():
          return None
      return pkg_resources.get_distribution('myproject').version

You can then use this function when you register a local component::

  local.component('mycode', '/path/to/directory/mycode', version=get_version())
